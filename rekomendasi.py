# -*- coding: utf-8 -*-
"""Untitled (4).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18yUlmtoX4CXo1Z1FB6FwqsgZB0J8Y7hA

**Import Liblary Yang di gunakan**
"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import hstack
from sklearn.metrics import average_precision_score
import numpy as np
from keras.models import Model
from keras.layers import Input, Embedding, Flatten, Dot
from keras.optimizers import Adam
from keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
import seaborn as sns
from keras.losses import Huber

"""**Lakukan Data Loading**"""

customers_df = pd.read_csv('olist_customers_dataset.csv')
order_reviews_df = pd.read_csv('olist_order_reviews_dataset.csv')
orders_df = pd.read_csv('olist_orders_dataset.csv')
products_df = pd.read_csv('olist_products_dataset.csv')
order_items_df = pd.read_csv('olist_order_items_dataset.csv')

"""Melihat Sampel 5 data dari customers_df"""

print("Customers DataFrame")
customers_df.head()

"""**Variabel Pada Customers_df**

customer_id: digunakan untuk mencatat transaksi atau interaksi pelanggan dalam platform tertentu bersifat unik untuk setiap Transaksi satu id menadakan 1 transaksi,

customer_unique_id: digunakan untuk mendapatkan informasi pelanggan yang konsisten dari berbagai platform yang berbeda bersifat unik 1 id  menadakan 1 user .

customer_zip_code_prefix: Ini adalah kode pos atau awalan kode pos pelanggan. Biasanya, kode pos ini digunakan untuk mengidentifikasi area geografis atau lokasi pelanggan. Awalan kode pos ini bisa merujuk pada wilayah atau kota tertentu.

customer_city: Ini adalah nama kota tempat pelanggan berada. Misalnya, dalam data ini ada kota-kota seperti "franca", "sao bernardo do campo", dan lainnya.

customer_state: Ini adalah nama negara bagian atau provinsi tempat pelanggan berada. Pada dataset ini, semuanya berada di negara bagian SP (São Paulo) di Brasil.

**Melihat Tipe data serta adakah yang Null dalam data**
"""

customers_df.info()

"""**Melkaukan Pengecekan apakah benar data id user dan unik id  benar benar unik**"""

count_all_unik_id = customers_df['customer_unique_id'].count()
print('count_all_unik_id : ',str(count_all_unik_id))

count_all_id = customers_df['customer_id'].count()
print('count_all_id : ',str(count_all_id))

"""**Memastikan Kembali Apakah ada data yang hilang**"""

missing_values = customers_df.isna().sum()

missing_values

"""**Menghapus Fitur Yang Tidak Di perlukan untuk sebuah rekomendasi diantara nya custemer state,customer_zip_code_prefix**"""

customers_df = customers_df.drop(columns=['customer_state', 'customer_zip_code_prefix'])
customers_df.head()

"""**melihat sampel data pada orders_df**"""

orders_df.head()



"""Melihat informasi data awal,seperti jumlah baris,kolom dan jumlah nan"""

orders_df.info()

"""Berikut adalah penjelasan variabel-variabel:

1. **order_id**: Merupakan ID unik yang mengidentifikasi setiap pesanan yang dilakukan oleh pelanggan.
   
2. **customer_id**: Merupakan ID unik yang mengidentifikasi setiap pelanggan yang melakukan pembelian.

3. **order_status**: Status dari pesanan, misalnya "delivered" menunjukkan bahwa pesanan telah berhasil dikirimkan kepada pelanggan.

4. **order_purchase_timestamp**: Waktu dan tanggal ketika pesanan dibuat oleh pelanggan.

5. **order_approved_at**: Waktu dan tanggal ketika pesanan disetujui oleh sistem atau pihak yang berwenang (misalnya sistem pembayaran atau verifikasi).

6. **order_delivered_carrier_date**: Tanggal dan waktu ketika pesanan diserahkan kepada pihak pengiriman atau kurir.

7. **order_delivered_customer_date**: Tanggal dan waktu ketika pesanan diterima oleh pelanggan setelah proses pengiriman.

8. **order_estimated_delivery_date**: Tanggal perkiraan kapan pesanan akan sampai ke pelanggan (dalam banyak kasus, ini adalah estimasi pengiriman yang disediakan oleh sistem atau kurir).

Data ini memberikan informasi yang mendetail mengenai timeline pesanan mulai dari pembelian hingga penerimaan barang oleh pelanggan.

**Memasikan coustumer_id tidak ada duplikat karena fitur ini akan selalu bernilai unik karena di buat di setiap transaksi**
"""

customer_counts = orders_df['customer_id'].value_counts()

# Ambil hanya customer_id yang muncul lebih dari sekali
duplicates = customer_counts[customer_counts > 1]

print(duplicates)

"""**Mengahpus kolom yang tidak berperan dalam sistem rekomendasi**"""

orders_df.drop(columns=[
    'order_purchase_timestamp',
    'order_approved_at',
    'order_delivered_carrier_date',
    'order_delivered_customer_date',
    'order_estimated_delivery_date'
], inplace=True)

"""**Memastikan kembali setiap fitur sudah sesuai dan melihat apakah ada yang kosong**"""

orders_df.info()

"""**melihat sampel pada dataframe order_reviews**"""

print("\nOrder Reviews DataFrame")
order_reviews_df.head()

"""Melihat informasi data awal,seperti jumlah baris,kolom dan jumlah nan"""

order_reviews_df.info()

"""Berikut adalah penjelasan variabel-variabel:

1. **review_id**: ID unik yang mengidentifikasi setiap ulasan yang diberikan oleh pelanggan.

2. **order_id**: ID pesanan yang terkait dengan ulasan tersebut. Ini menghubungkan ulasan dengan pesanan yang dibeli.

3. **review_score**: Skor yang diberikan oleh pelanggan untuk produk yang dibeli. Skor ini biasanya dalam bentuk angka, misalnya dari 1 hingga 5, untuk menunjukkan tingkat kepuasan pelanggan terhadap produk.

4. **review_comment_title**: Judul dari ulasan yang diberikan. Biasanya ini adalah ringkasan atau headline yang menggambarkan pendapat umum pelanggan tentang produk.

5. **review_comment_message**: Pesan atau deskripsi lengkap dari ulasan yang diberikan oleh pelanggan. Bagian ini memberikan detail lebih lanjut tentang pengalaman mereka dengan produk.

6. **review_creation_date**: Tanggal dan waktu saat ulasan dibuat oleh pelanggan. Ini memberi informasi kapan pelanggan memberikan feedback terhadap produk.

7. **review_answer_timestamp**: Tanggal dan waktu ketika ulasan dijawab oleh pihak penjual atau sistem. Ini menunjukkan kapan ulasan tersebut mendapatkan respons (jika ada).

Menghapus_kolom yang tidak perlu
"""

order_reviews_df.drop(columns=['review_comment_title','review_comment_message','review_creation_date','review_answer_timestamp'],inplace=True)

"""**Kembali Menglihat sampel data setelah pemilahan fitur**"""

order_reviews_df.head()

"""**Melihat apakah ada yang null atau tidak dalam data frame order_reviews**"""

order_reviews_df.info()

"""**Visualisasi sebaran data Review Score Dan melihat rarat score secara umum**"""

plt.figure(figsize=(8, 6))
plt.hist(order_reviews_df['review_score'], bins=5, color='skyblue', edgecolor='black')
plt.title('Sebaran Data Review Score', fontsize=14)
plt.xlabel('Review Score', fontsize=12)
plt.ylabel('Frekuensi', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# 2. Proporsi Pengguna Memberikan Rating Maksimal
total_reviews = len(order_reviews_df)
max_rating_count = len(order_reviews_df[order_reviews_df['review_score'] == 5])
max_rating_proportion = (max_rating_count / total_reviews) * 100

# 3. Rata-rata Review Score Secara Umum
avg_review_score = order_reviews_df['review_score'].mean()

print(f"Proporsi pengguna yang memberikan rating maksimal (5): {max_rating_proportion:.2f}%")
print(f"Rata-rata review score secara umum: {avg_review_score:.2f}")

"""**melihat_sampel data dari order_items_df**"""

print("\norder_items_df")
order_items_df.head(n=10)

"""Melihat informasi data awal,seperti jumlah baris,kolom dan jumlah nan"""

order_items_df.info()

"""Berikut adalah penjelasan untuk setiap variabel yang terdapat dalam data ini:

1. **order_id**: ID unik yang mengidentifikasi pesanan. Ini menghubungkan item yang dibeli dalam satu transaksi atau pesanan.

2. **order_item_id**: ID unik untuk setiap item dalam pesanan. Dalam satu pesanan bisa ada lebih dari satu item, dan ID ini mengidentifikasi item spesifik.

3. **product_id**: ID unik yang mengidentifikasi produk yang dibeli. Ini merujuk pada produk spesifik yang dipesan dalam transaksi tersebut.

4. **seller_id**: ID unik yang mengidentifikasi penjual produk tersebut. Setiap penjual memiliki ID yang berbeda untuk membedakan mereka dalam sistem.

5. **shipping_limit_date**: Tanggal dan waktu batas akhir untuk pengiriman produk, yang menunjukkan kapan penjual harus mengirimkan barang tersebut kepada pelanggan.

6. **price**: Harga produk yang dibeli, biasanya dalam mata uang tertentu. Ini adalah biaya dasar produk tanpa mempertimbangkan biaya pengiriman.

7. **freight_value**: Biaya pengiriman yang dikenakan untuk produk tersebut. Ini adalah biaya tambahan untuk pengiriman barang kepada pelanggan, yang dapat bervariasi berdasarkan lokasi pengiriman, berat produk, dan lainnya.

**menghapus kolom yang tidak di pelukan**
"""

order_items_df.drop(columns=['seller_id','shipping_limit_date'],inplace=True)

order_items_df['total_value'] = order_items_df['price'] + order_items_df['freight_value']

"""**Membuat kolom baru total_value hasil penjumlahan dari kolom price dan kolom freight_value**

**Melihat tipe data dan adakah data yang null**
"""

order_items_df.info()

"""**Melihat sampel data dari order_items**"""

order_items_df.head()

"""**Melihat top 5  produks bedasrkan total_value dan freight_value**"""

top_5_freight_value = order_items_df.groupby('product_id')['freight_value'].sum().nlargest(5)

# 3. Top 5 produk berdasarkan total_value
top_5_total_value = order_items_df.groupby('product_id')['total_value'].sum().nlargest(5)

plt.figure(figsize=(10, 6))
plt.bar(top_5_freight_value.index, top_5_freight_value.values, color='lightgreen')
plt.title('Top 5 harga tertinggi Produk Berdasarkan Freight Value')
plt.xlabel('Product ID')
plt.ylabel('Total Freight Value')

# Rotasi label x-axis agar tidak tabrakan, secara vertikal
plt.xticks(rotation=90)

# Menata layout agar grafik tidak terpotong
plt.tight_layout()
plt.show()

# Plotting
plt.figure(figsize=(10, 6))
plt.bar(top_5_total_value.index, top_5_total_value.values, color='lightcoral')
plt.title('Top 5 harga tertinggi Produk Berdasarkan Total Value')
plt.xlabel('Product ID')
plt.ylabel('Total Value')

# Rotasi label x-axis agar tidak tabrakan, secara vertikal
plt.xticks(rotation=90)

# Menata layout agar grafik tidak terpotong
plt.tight_layout()
plt.show()

"""**Melihat  sampel data Produk **"""

print("\nProducts DataFrame")
products_df.head(n=10)

"""Melihat informasi data awal,seperti jumlah baris,kolom dan jumlah nan"""

products_df.info()

"""Berikut adalah penjelasan untuk setiap variabel dalam data ini:

1. **product_id**: ID unik yang mengidentifikasi produk di dalam sistem. Ini digunakan untuk membedakan produk yang satu dengan produk lainnya.

2. **product_category_name**: Nama kategori produk, misalnya "perfumaria" (kategori produk parfum). Ini mengelompokkan produk berdasarkan jenisnya.

3. **product_name_lenght**: Panjang nama produk dalam karakter. Ini memberikan informasi tentang panjang karakter dari nama produk yang tercatat dalam sistem.

4. **product_description_lenght**: Panjang deskripsi produk dalam karakter. Ini menunjukkan panjang karakter dari deskripsi yang menyertai produk, yang memberi informasi lebih lanjut mengenai produk tersebut.

5. **product_photos_qty**: Jumlah foto yang tersedia untuk produk tersebut. Ini memberi gambaran tentang seberapa banyak gambar yang diunggah oleh penjual untuk menggambarkan produk.

6. **product_weight_g**: Berat produk dalam gram. Ini menunjukkan seberapa berat produk tersebut, yang penting untuk perhitungan pengiriman.

7. **product_length_cm**: Panjang produk dalam sentimeter. Ini memberi ukuran dimensi panjang produk.

8. **product_height_cm**: Tinggi produk dalam sentimeter. Ini memberi ukuran dimensi tinggi produk.

9. **product_width_cm**: Lebar produk dalam sentimeter. Ini memberi ukuran dimensi lebar produk.

**menghapus fitur yang tidak di perlukan**
"""

products_df.drop(columns=['product_photos_qty','product_description_lenght','product_name_lenght'],inplace=True)

"""Melihat apakah ada data yang nan"""

nan_counts = products_df.isna().sum()

# Menampilkan hasil
print(nan_counts)

"""**penghapusan data yang hilang**"""

# Menghapus kolom yang seluruh isinya NaN
products_df_cleaned = products_df.dropna(axis=1, how='all')

"""**melihat kembali sampel data setelah di preprocesing**"""

products_df_cleaned.head()

"""**Proses penggabungan data**

bertujuan untuk menyatukan informasi dari berbagai sumber dalam satu DataFrame yang komprehensif. Dimulai dengan menghubungkan data pelanggan dan pesanan berdasarkan `customer_id`, memastikan semua pelanggan tetap tercatat meskipun tidak memiliki pesanan. Selanjutnya, data ulasan pesanan ditambahkan menggunakan `order_id` agar setiap pesanan yang memiliki ulasan dapat disertakan. Proses ini dilanjutkan dengan menggabungkan item pesanan berdasarkan `order_id`, sehingga setiap pesanan mencantumkan detail produk yang dipesan. Terakhir, informasi produk ditambahkan melalui `product_id` untuk melengkapi detail barang yang dibeli. Dengan metode **left join**, data utama seperti pelanggan dan pesanan tetap dipertahankan meskipun tidak semua pesanan memiliki ulasan, item, atau produk terkait. Hasil akhirnya adalah satu tabel yang mengintegrasikan seluruh informasi pelanggan, pesanan, ulasan, item pesanan, dan produk untuk analisis yang lebih mendalam.
"""

# Menggabungkan customers_df dan order_reviews_df berdasarkan customer_id dan order_id
merged_df = pd.merge(customers_df,orders_df, on='customer_id', how='left')
merged_df = pd.merge(merged_df, order_reviews_df, on='order_id', how='left')
merged_df = pd.merge(merged_df, order_items_df, on='order_id', how='left')
merged_df = pd.merge(merged_df, products_df, on='product_id', how='left')

"""**melihat data frame baru hasil pegabungan**"""

merged_df.head()

"""Berikut adalah penjelasan mengenai masing-masing variabel dalam data ini:

1. **customer_id**: ID unik untuk masing-masing pelanggan. Ini digunakan untuk mengidentifikasi pelanggan dalam sistem.

2. **customer_unique_id**: ID pelanggan yang lebih permanen dan unik di seluruh sistem, yang memungkinkan identifikasi pelanggan meskipun mereka melakukan pembelian dengan beberapa akun.

3. **customer_city**: Kota tempat tinggal pelanggan, yang memberikan informasi mengenai lokasi geografis pelanggan.

4. **order_id**: ID unik untuk setiap pesanan. Ini digunakan untuk mengidentifikasi pesanan tertentu dalam sistem.

5. **order_status**: Status pesanan, misalnya "delivered", yang menunjukkan apakah pesanan telah berhasil dikirimkan dan diterima oleh pelanggan.

6. **review_id**: ID unik untuk setiap ulasan yang diberikan oleh pelanggan. Ini digunakan untuk mengidentifikasi ulasan yang terkait dengan produk atau pesanan.

7. **review_score**: Skor ulasan yang diberikan oleh pelanggan untuk produk tersebut, biasanya dalam skala 1-5. Ini memberi gambaran tentang kepuasan pelanggan terhadap produk yang dibeli.

8. **order_item_id**: ID unik untuk setiap item yang dipesan dalam satu pesanan. Ini digunakan untuk mengidentifikasi item spesifik dalam pesanan yang lebih besar.

9. **product_id**: ID unik untuk produk yang dipesan. Ini mengidentifikasi produk tertentu yang dibeli oleh pelanggan.

10. **price**: Harga produk sebelum biaya pengiriman. Ini memberikan informasi mengenai harga produk yang dipesan.

11. **freight_value**: Biaya pengiriman yang dikenakan untuk pesanan produk. Ini adalah biaya yang dibebankan kepada pelanggan untuk pengiriman barang.

12. **total_value**: Total nilai pesanan, yang merupakan jumlah dari harga produk dan biaya pengiriman. Ini menunjukkan biaya total yang dibayar pelanggan untuk produk dan pengiriman.

13. **product_category_name**: Nama kategori produk, seperti "moveis_escritorio" (furniture kantor) atau "utilidades_domesticas" (peralatan rumah tangga). Ini mengelompokkan produk berdasarkan jenisnya.

14. **product_weight_g**: Berat produk dalam gram. Ini menunjukkan berat produk yang dipesan.

15. **product_length_cm**: Panjang produk dalam sentimeter. Ini menunjukkan dimensi panjang produk.

16. **product_height_cm**: Tinggi produk dalam sentimeter. Ini menunjukkan dimensi tinggi produk.

17. **product_width_cm**: Lebar produk dalam sentimeter. Ini menunjukkan dimensi lebar produk.

**Melihat Kembali tipe data dan apakah ada yang null di dalam datased merged**
"""

merged_df.info()

"""**Menghapus seluruh data yang null atau hilang**"""

merged_df_cleaned = merged_df.dropna()

"""**Melihat kembali apakah ada data yang hilang atau tidal**"""

merged_df_cleaned.info()

"""**Melihat Sampel data yang sudah di preprocesing**"""

merged_df_cleaned.head()

"""**Memastikan bahwa customer_id unik dan jika duplikat akan di hapus**"""

# Menghitung jumlah kemunculan 'customer_id'
customer_counts = merged_df_cleaned['customer_id'].value_counts()

# Ambil hanya customer_id yang muncul lebih dari sekali
duplicates = customer_counts[customer_counts > 1]


# Menghapus duplikat, hanya mempertahankan satu entri per 'customer_id'
# Bisa memilih yang pertama atau yang terakhir berdasarkan kebutuhan
merged_df_cleaned_no_duplicates = merged_df_cleaned.drop_duplicates(subset='customer_id', keep='first')

customer_counts = merged_df_cleaned_no_duplicates['customer_id'].value_counts()

# Ambil hanya customer_id yang muncul lebih dari sekali
duplicates = customer_counts[customer_counts > 1]

# Menampilkan 'customer_id' yang duplikat
print(duplicates)

"""**Kembali melihat sampel data dari preprocesing**"""

merged_df_cleaned_no_duplicates.head()

"""**Melihat di mensi data yang akan di gunakana**"""

merged_df_cleaned_no_duplicates.shape

"""**Melihat top 5 Produk bedasrkan rata rata review score**"""

top_5_review_scores_df =  merged_df_cleaned_no_duplicates.groupby('product_category_name')['review_score'].mean().nlargest(5).reset_index()
print(top_5_review_scores_df)

"""Proses ini bertujuan untuk membangun representasi fitur produk guna menghitung kesamaan antar produk berdasarkan kategori dan atribut fisiknya. Pertama, diambil 20.000 sampel data dari `merged_df_cleaned_no_duplicates` untuk memastikan efisiensi dalam pemrosesan. Fitur yang digunakan meliputi kategori produk (`product_category_name`) sebagai data kategorikal serta atribut berat dan dimensi sebagai data numerik. Untuk mengolah kategori produk, digunakan metode **TF-IDF (Term Frequency-Inverse Document Frequency)** guna mengubah teks menjadi representasi numerik yang mencerminkan pentingnya suatu kategori dalam dataset. Sementara itu, fitur numerik seperti berat dan dimensi dinormalisasi menggunakan **StandardScaler** agar memiliki distribusi yang sebanding. Hasil representasi kategori dan fitur numerik kemudian digabungkan untuk membentuk satu matriks fitur yang lengkap. Langkah terakhir adalah menghitung **cosine similarity**, yaitu ukuran kesamaan antara produk berdasarkan fitur yang telah diproses, sehingga dapat digunakan untuk analisis keterkaitan atau rekomendasi produk."""

# Mengambil hanya 100 sampel data dari merged_df_cleaned_no_duplicates
sample_data = merged_df_cleaned_no_duplicates.sample(n=20000, random_state=42)

# Fitur yang akan digunakan
categories = sample_data['product_category_name']
numeric_features = ['product_weight_g', 'product_length_cm', 'product_height_cm', 'product_width_cm']

# Menggunakan TF-IDF untuk fitur kategorikal (product_category_name)
tfidf = TfidfVectorizer(stop_words='english')
category_tfidf = tfidf.fit_transform(categories)

# Normalisasi fitur numerik menggunakan StandardScaler
scaler = StandardScaler()
numeric_data = scaler.fit_transform(sample_data[numeric_features])

# Gabungkan hasil TF-IDF dan fitur numerik
features_combined = hstack([category_tfidf, numeric_data])

# Menghitung cosine similarity antar produk
cos_sim = cosine_similarity(features_combined)

""" proses untuk mengevaluasi kinerja sistem rekomendasi produk dengan mengukur Precision, Recal berdasarkan kemiripan produk. PrecisionK menghitung persentase produk yang direkomendasikan dalam K produk teratas yang benar-benar relevan, sementara Recall@K mengukur seberapa banyak produk relevan yang berhasil ditemukan dari total produk relevan yang tersedia. Proses evaluasi dimulai dengan menghitung kesamaan antar produk menggunakan cosine similarity, lalu untuk setiap produk, dipilih K produk dengan skor kesamaan tertinggi sebagai rekomendasi. Precision dan Recall dihitung dengan membandingkan produk yang direkomendasikan dengan produk yang seharusnya relevan. Selanjutnya, MAP@K digunakan untuk menilai kualitas rekomendasi secara keseluruhan dengan menghitung rata-rata presisi pada berbagai posisi dalam daftar peringkat. Hasil akhirnya adalah metrik evaluasi yang memberikan gambaran seberapa akurat sistem dalam merekomendasikan produk kepada pengguna."""

# Fungsi untuk menghitung Precision dan Recall pada K produk teratas
def precision_recall_at_k(cos_sim, df, top_n=3):
    precision_list = []
    recall_list = []

    # Menghitung Precision dan Recall untuk setiap produk
    for idx in range(len(df)):
        # Mengambil skor kesamaan produk terhadap produk lainnya
        sim_scores = list(enumerate(cos_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        # Mengambil K produk teratas
        top_k_indices = [i[0] for i in sim_scores[1:top_n+1]]

        # Menghitung Precision dan Recall
        relevant_items = set(top_k_indices)  # Produk relevan yang telah dipilih
        retrieved_items = set(top_k_indices)  # Produk yang telah direkomendasikan

        precision = len(retrieved_items & relevant_items) / len(retrieved_items) if len(retrieved_items) > 0 else 0
        recall = len(retrieved_items & relevant_items) / len(relevant_items) if len(relevant_items) > 0 else 0

        precision_list.append(precision)
        recall_list.append(recall)

    avg_precision = np.mean(precision_list)
    avg_recall = np.mean(recall_list)

    return avg_precision, avg_recall

# Fungsi untuk menghitung MAP@K
def mean_average_precision_at_k(cos_sim, df, top_n=3):
    avg_precision_list = []

    for idx in range(len(df)):
        sim_scores = list(enumerate(cos_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        top_k_indices = [i[0] for i in sim_scores[1:top_n+1]]

        # Asumsikan produk relevan yang dipilih memiliki relevansi 1
        # relevansi dapat berupa 1 untuk relevan, 0 untuk tidak relevan
        relevances = [1 if i in top_k_indices else 0 for i in range(len(df))]

        # Menggunakan skor kesamaan sebagai prediksi untuk menghitung rata-rata presisi
        relevance_scores = [x[1] for x in sim_scores[1:top_n+1]]

        try:
            avg_precision = average_precision_score(relevances, relevance_scores)
            avg_precision_list.append(avg_precision)
        except ValueError:
            # Jika terjadi error karena tidak ada variasi dalam relevansi
            continue

    return np.mean(avg_precision_list) if avg_precision_list else 0

# Evaluasi Precision@K, Recall@K dan MAP@K
top_n = 3  # Mengambil 3 produk teratas
precision, recall = precision_recall_at_k(cos_sim, sample_data, top_n)
map_k = mean_average_precision_at_k(cos_sim, sample_data, top_n)

print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")

"""proses ini untuk merekomendasikan produk berdasarkan kategori yang dipilih dengan memanfaatkan cosine similarity antara produk. Proses dimulai dengan mencari semua produk dalam dataset yang memiliki kategori yang sesuai. Jika tidak ada produk dalam kategori tersebut, maka fungsi akan mengembalikan DataFrame kosong sebagai indikasi bahwa tidak ada produk yang bisa direkomendasikan. Selanjutnya, untuk setiap produk dalam kategori yang ditemukan, dihitung kesamaan dengan semua produk lain dalam dataset menggunakan matriks kesamaan (cos_sim). Setelah itu, produk diurutkan berdasarkan nilai kesamaan tertinggi, dan top-N produk teratas dipilih sebagai rekomendasi, dengan pengecualian produk itu sendiri agar tidak muncul dalam daftar rekomendasi. Hasil akhir dari fungsi ini adalah subset DataFrame yang berisi produk-produk yang paling mirip berdasarkan kategori dan fitur yang telah diproses sebelumnya."""

# Fungsi untuk merekomendasikan produk berdasarkan index produk
def recommend_by_category(category, cos_sim, df, top_n=3):
    # Menemukan semua produk yang memiliki kategori yang sama
    category_idx = df[df['product_category_name'] == category].index.tolist()

    # Memastikan kategori yang ditemukan memiliki produk dalam data sampel
    if not category_idx:
        print(f"Tidak ada produk dalam kategori {category}")
        return pd.DataFrame()  # Mengembalikan DataFrame kosong jika kategori tidak ditemukan

    # Mendapatkan nilai kesamaan dengan produk lainnya
    sim_scores = []
    for idx in category_idx:
        # Pastikan indeks ada dalam range ukuran data yang disampel
        if idx < cos_sim.shape[0]:
            sim_scores.extend(list(enumerate(cos_sim[idx])))

    # Mengurutkan produk berdasarkan skor kesamaan tertinggi
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Mengambil top_n produk rekomendasi
    sim_scores = sim_scores[1:top_n+1]  # Menghindari produk itu sendiri
    product_indices = [i[0] for i in sim_scores]
    return df.iloc[product_indices]

"""proses ini digunakan untuk mendapatkan rekomendasi produk berdasarkan kategori tertentu dengan memilih produk yang memiliki kemiripan tertinggi dalam kategori tersebut. Pertama, kategori yang dicari ditentukan (category_to_search = 'automotivo'). Kemudian, fungsi recommend_by_category dipanggil untuk mencari produk dalam kategori "automotivo" yang memiliki kesamaan fitur dengan produk lain berdasarkan cosine similarity (cos_sim). Hasil rekomendasi berupa 5 produk teratas dengan nilai kesamaan tertinggi yang akan disimpan dalam recommended_products. Terakhir, hasil rekomendasi ditampilkan dengan hanya menyertakan informasi kategori, berat, panjang, tinggi, dan lebar produk, sehingga pengguna dapat melihat perbandingan fitur dari produk yang direkomendasikan."""

category_to_search = 'automotivo'  # Ganti dengan kategori yang diinginkan
recommended_products = recommend_by_category(category_to_search, cos_sim, sample_data, top_n=5)
print(recommended_products[['product_category_name', 'product_weight_g', 'product_length_cm', 'product_height_cm', 'product_width_cm']])

"""**mengcopy data ke data frame baru yang bertujuan untuk melakukan exprimen untuk membagun model**"""

reza= sample_data.copy()

"""proses ini membangun model **rekomendasi berbasis faktor tersembunyi (latent factor model)** menggunakan **Neural Collaborative Filtering (NCF)** untuk memprediksi **review score** berdasarkan pelanggan dan kategori produk.  

**Tahapan utama dalam kode:**  
1. **Preprocessing Data** – Fitur numerik seperti harga (`price`), ongkos kirim (`freight_value`), dan total (`total_value`) disiapkan. Label target adalah `review_score`, sedangkan pelanggan (`customer_unique_id`) dan produk (`product_category_name`) dikodekan menjadi nilai numerik.  
2. **Normalisasi & Split Data** – `review_score` dinormalisasi menggunakan `MinMaxScaler()`, lalu data dibagi menjadi **80% data latih dan 20% data uji**.  
3. **Arsitektur Model** – Model dibuat menggunakan dua **embedding layer** untuk pelanggan dan produk, yang kemudian dikombinasikan dengan operasi **dot product** untuk menangkap hubungan antar entitas. Hasilnya kemudian diratakan (`Flatten()`) untuk menghasilkan skor prediksi.  
4. **Pelatihan Model** – Model dikompilasi dengan **Adam optimizer** dan **Huber loss**, serta dilatih dengan teknik **early stopping** untuk mencegah overfitting.  
5. **Evaluasi Model** – Model diuji menggunakan **Mean Absolute Error (MAE)** untuk mengukur performanya.  
6. **Cosine Similarity** – Setelah pelatihan, embedding yang telah dipelajari dianalisis dengan **cosine similarity**, baik untuk pelanggan maupun produk, guna memahami pola kesamaan dalam representasi vektor.  

Hasil dari model ini dapat digunakan untuk memberikan rekomendasi produk yang lebih personal kepada pelanggan berdasarkan pola ulasan mereka sebelumnya.
"""

# Data Preprocessing
features = ['price', 'freight_value', 'total_value']
y = reza['review_score']
customers = reza['customer_unique_id']
products = reza['product_category_name']

# Encode categorical features
customers_encoded = customers.factorize()[0]
products_encoded = products.factorize()[0]

# Scale review scores
scaler = MinMaxScaler()
y_scaled = scaler.fit_transform(y.values.reshape(-1, 1)).flatten()

# Train-test split
customers_train, customers_test, products_train, products_test, y_train, y_test = train_test_split(
    customers_encoded, products_encoded, y_scaled, test_size=0.2, random_state=42
)

# Define model
embedding_dim = 150

# Inputs
user_input = Input(shape=(1,), name='user_input', dtype='int32')
product_input = Input(shape=(1,), name='product_input', dtype='int32')

# Embedding layers
user_embedding = Embedding(input_dim=len(customers.unique()) + 1, output_dim=embedding_dim, name="user_embedding")(user_input)
product_embedding = Embedding(input_dim=len(products.unique()) + 1, output_dim=embedding_dim, name="product_embedding")(product_input)

# Dot product
dot_product = Dot(axes=-1, normalize=False)([user_embedding, product_embedding])

# Flatten output
output = Flatten()(dot_product)

# Compile model
model = Model(inputs=[user_input, product_input], outputs=output)
model.compile(optimizer=Adam(), loss=Huber(), metrics=['mae'])

# Early stopping
early_stop = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

# Train model
history = model.fit(
    [customers_train, products_train],
    y_train,
    validation_data=([customers_test, products_test], y_test),
    epochs=10,
    batch_size=32,
    verbose=1,
    callbacks=[early_stop]
)

# Evaluate model
loss, mae = model.evaluate([customers_test, products_test], y_test)
print(f"\nTest Loss: {loss:.4f}, Test MAE: {mae:.4f}")

# Optional: Print Cosine Similarity for the first few customers and products
user_embedding_matrix = model.get_layer("user_embedding").get_weights()[0]
product_embedding_matrix = model.get_layer("product_embedding").get_weights()[0]

user_similarity = cosine_similarity(user_embedding_matrix[:10])  # Check for first 10 users
product_similarity = cosine_similarity(product_embedding_matrix[:10])  # Check for first 10 products

print("\nUser Similarity Matrix (Top 10):")
print(user_similarity)

print("\nProduct Similarity Matrix (Top 10):")
print(product_similarity)

"""**Melakukan rekomendasi terhadap id user dengan cara**

1. **Menentukan `user_id`**: Menentukan ID pengguna yang ingin diberikan rekomendasi produk.
2. **Mencari `user_idx`**: Menemukan posisi pengguna dalam dataset berdasarkan `user_id`.
3. **Input untuk Model**: Membuat input untuk model dengan memasukkan ID pengguna dan ID produk.
4. **Prediksi**: Model menghitung skor relevansi antara pengguna dan produk.
5. **Top Produk**: Mengambil produk dengan skor tertinggi berdasarkan prediksi.
6. **Tampilkan Rekomendasi**: Menampilkan produk yang direkomendasikan dengan kategori asli.

Kode ini memberikan **5 produk teratas** yang direkomendasikan berdasarkan skor prediksi dari model.
"""

# Misalkan user_id adalah string yang ingin direkomendasikan
user_id = '12d43aa0d63d45af21a491244b44e73e'  # Ganti dengan ID pengguna yang diinginkan

user_idx = np.where(customers_encoded == customers.factorize()[0])[0][0]

# Produk yang sudah di-encode
unique_products = np.unique(products_encoded)  # Perbaikan di sini

# Membuat pasangan ID produk untuk setiap user_id tertentu
user_input_data = np.full((len(unique_products), 1), user_idx)  # Input ID user
product_input_data = unique_products.reshape(-1, 1)  # Input produk untuk semua produk yang unik

# Prediksi skor untuk semua produk
predicted_scores = model.predict([user_input_data, product_input_data])

# Menemukan produk dengan skor tertinggi
top_product_indices = np.argsort(predicted_scores.flatten())[::-1][:5]  # Ambil 5 produk teratas

# Menampilkan produk yang direkomendasikan (kembali ke format kategori asli)
recommended_products = products.iloc[top_product_indices]

# Pastikan tidak ada produk yang berulang
recommended_products_unique = recommended_products.drop_duplicates()

print(f"Rekomendasi untuk user ID {user_id} adalah produk-produk berikut:")
print(recommended_products_unique)